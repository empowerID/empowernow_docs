# PDP Policy DSL – Quick Reference

> **Need narrative examples and audit checklist?** See [policy_author_guide.md](policy_author_guide.md).

> **Updated automatically:** keep this file in sync with the YAMLPolicyParser & ConditionParser.

---

## 1. File Skeleton
```yaml
id: example-policy
name: Human-readable Name
version: "1.0"

subjects:
  - type: user   # or agent / service / group …
    id: "*"      # wildcard or literal

rules:
  - id: rule-1
    resource: "document"
    action: "read"
    effect: permit     # permit | deny
    condition: subject.properties.clearance >= resource.properties.classification
    obligations: []    # optional – see §4
```

---

## 2. Condition Language
| Supported scope | Example                       |
|-----------------|--------------------------------|
| `subject`       | `subject.id == 'alice'`        |
| `resource`      | `resource.type == 'file'`      |
| `action`        | `action.name == 'delete'`      |
| `context`       | `context.request_ip == '1.1.1.1'` |
| `environment`   | `environment.current_time < '18:00:00'` |

### Operators
`==  !=  >  <  >=  <=  IN  NOT IN  LIKE  NOT LIKE  MATCHES  NOT MATCHES`

Dict-only helpers (not valid in string form): `contains`, `startswith`, `endswith`, `path_match`, `path_match_any`, `cidr_match`, `ip_range`, `date_range`, `equals_after_type_conversion`, `money_*`, `velocity_within`.

Logical connectors: `AND`, `OR`, `NOT`

Syntactic sugar:
* `allowIf`, `denyIf`, `when`, `unless`, `exceptIf`, `none`, `all`, `any`, `not`, `If`/`Then`/`Else`

Examples
```yaml
when:
  all:
    - subject.role IN ['manager', 'director']
    - resource.sensitivity <= 2
```

---

## 3. Obligations & Constraints
Both share the same literal shape – the evaluator distinguishes by context.
```yaml
obligations:
  - id: log_access
    attributes:
      level: detailed
constraints:
  - id: spend_cap
    type: numeric_limit
    value: 5000
```
*   Put custom data under `attributes:` (obligations) or at top-level except `id`/`type` (constraints).
*   The parser automatically converts `constraints:` inside `on_permit` / `on_deny` to obligation objects.

---

## 4. Effect mapping rules
| Field present      | Automatic `effect` value |
|--------------------|--------------------------|
| `allowIf`          | permit                  |
| `denyIf`           | deny                    |
| `effect` missing   | permit (default)        |

> Guard semantics: Use `when` to guard a rule so that a false condition yields `not_applicable`. Pairing `allowIf` with `effect: permit` acts as an override, not a guard, and can over-permit if the condition is false.

---

## 5. Common gotchas
* Use `AND` / `OR` **not** `&&` / `||`.
* `is not None` is unsupported – use `!= None`.
* Custom subject / resource data must be under `properties`.
* Only the five scopes above resolve attributes; `principal.*` or `ctx.*` will be `None`.
* Do not use `conditions` (plural). Supported keys are `condition` (singular) or sugar: `allowIf` / `denyIf` / `when` / `unless` / `exceptIf`. The plural key is ignored and will cause rules to behave as unconditional.
* Prefer `when` for "permit-only-on-match". `allowIf + effect: permit` keeps permit on false and is not a guard.

---

## 6. CLI Helpers
* Validate a policy:  `python tools/policy_lint.py my_policy.yaml`
* Pretty-print a Condition: `ConditionParser.to_natural_language(cond)` (Python REPL).

---

## 7. Full syntax catalogue (auto-derived)

> The tables below were generated by scanning `YAMLPolicyParser`, `ConditionParser`, `ExpressionEvaluator` and the Pydantic models.  If you add an operator/field in code, regenerate this file.

### 7.1 Rule-level keys
| Key | Required | Notes |
|-----|----------|-------|
| `id` | no | Defaults to `resource:action` if omitted |
| `description` | no | free-text |
| `resource` | **yes** | string (`"doc"`) or dict `{type,id}`.  Wildcards with `*` supported |
| `action` | **yes** | string or list.  Wildcard `*` allowed |
| `effect` | auto | `permit` / `deny`.  Overridden by sugar fields – see §7.3 |
| `condition` | no | structured/dotted expression; may embed `all/any/not/none` |
| `allowIf` / `denyIf` | no | string / dict / list sugar that sets effect automatically |
| `when` / `unless` / `exceptIf` | no | logical sugar wrappers (`when` acts as a guard; false → `not_applicable`) |
| `If` / `Then` / `Else` | no | branching sugar (`If` expression evaluated → chooses Then/Else sub-rule) |
| `on_permit` / `on_deny` | no | obligations **or** constraints; parser normalises |
| `conditions` | — | Unsupported alias. Use `condition` or sugar (`allowIf`/`denyIf`/`when`/`unless`/`exceptIf`). |

### 7.2 Syntactic-sugar → effect resolution
Priority (high → low):
1. `allowIf` sets effect **permit**
2. `denyIf`  sets effect **deny**
3. `effect:` explicit value (if neither sugar present)
4. default **permit**

> Use `when` to gate rule applicability. If `when` is false, the rule is `not_applicable` and contributes no decision.

### 7.3 Supported operators (string form)
`==  !=  >  <  >=  <=  IN  NOT IN  LIKE  NOT LIKE  MATCHES  NOT MATCHES`

Special operators exposed by `ExpressionEvaluator`:
* `path_match` / `path_match_any`
* `money_equals` / `money_greater_than` … (prefixed `money_`)
* `velocity_within`
* `cidr_match`, `ip_range`, `date_range`

Time / environment shorthands (`TIME_OPERATORS`):
`during_business_hours`, `on_weekday`, `on_weekend`, `after_date`, `before_date`, `after_time`, `before_time`

### 7.4 Attribute scopes
| Scope | Resolved by | Example path |
|-------|-------------|--------------|
| `subject` | `_get_subject_attribute` | `subject.properties.role` |
| `resource`| `_get_resource_attribute` | `resource.type` |
| `action`  | `_get_action_attribute` | `action.name` |
| `context` | `_get_context_attribute` | `context.request_ip` |
| `environment` | `_get_environment_attribute` | `environment.current_time` |

### 7.5 Dynamic subjects
```yaml
subjects:
  - where: subject.properties.roles IN ['admin','manager']
  - type: group
    id: sales
```
The `where:` value is parsed by **ConditionParser** identically to rule conditions.

### 7.6 Path-attribute matching
Policies may declare path attribute patterns (see `policy.path_attributes`) and use:
```yaml
condition: resource.properties.full_path MATCHES path_attr_downloads
```
Internally `MATCHES` resolves the right-hand side against `resource.path_attributes`.

> Note: Prefer the `MATCHES path_attr_name` form in `condition`/sugar. A `path_conditions:` helper exists in the evaluator for advanced cases, but `MATCHES` is the supported, portable way and maps cleanly to the path-attribute schema.

---

## 8.1 Guarded permits — examples and alternatives

### Anti-pattern (over-permitting)
False condition → base effect stays `permit`; rule still permits.

```yaml
# Avoid: allowIf + effect: permit (override, not guard)
- description: "EntraID user forms"
  resource: "form"
  action: ["read","submit","update"]
  effect: "permit"
  allowIf: "resource.properties.resource_id in ['av_entraid_create_user_form','av_entraid_view_user_form']"
```

### Recommended (true guard)
True → permit; false → `not_applicable`.

```yaml
- description: "EntraID user forms (guarded)"
  resource: "form"
  action: ["read","submit","update"]
  effect: "permit"
  when: "resource.properties.resource_id in ['av_entraid_create_user_form','av_entraid_view_user_form']"
```

### Alternatives
- Default-deny and open on match:

```yaml
- description: "EntraID user forms (default deny)"
  resource: "form"
  action: ["read","submit","update"]
  effect: "deny"
  allowIf: "resource.properties.resource_id in ['av_entraid_create_user_form','av_entraid_view_user_form']"
```

- Default-permit but explicitly deny non-listed:

```yaml
- description: "EntraID user forms (deny negative)"
  resource: "form"
  action: ["read","submit","update"]
  effect: "permit"
  denyIf: "resource.properties.resource_id not in ['av_entraid_create_user_form','av_entraid_view_user_form']"
```

### Lint suggestion
- Flag `allowIf` present with `effect: permit` unless waived; suggest using `when` or flipping base `effect` to `deny`.

### Testing checklist
- Positive: matching id → permit via this rule.
- Negative: non-matching id → rule `not_applicable`; final allow only if another rule permits; otherwise deny.

### 7.7 Constraints vs Obligations cheat-sheet
| Field | Meaning in evaluator |
|-------|---------------------|
| `_constraint: true` (auto) | Parser marks items that originated in `constraints:`
| `type:` | Semantic classifier (`numeric_limit`, `geo_restriction`, …) |
| Arbitrary keys | land in `attributes` (oblig.) or `parameters` (constraint model) |

---

## 8. Effect of placeholders / templates
Strings wrapped in `{{ … }}` are **not** evaluated by PDP; they are just carried through to the caller (IdP or downstream PEP) for later substitution.

---

## 9. Regeneration instructions
Run `python tools/update_cheatsheet.py` *(TODO)* after changing parser code to refresh operators & field lists.

---

*Generated `{{date}}` by docs maintainers.* 

## 10. Combining algorithm & defaults
| Situation | Result |
|-----------|--------|
| **Any** rule with `effect: deny` or `denyIf` evaluates *true* | Final decision = **DENY** (deny-override) |
| At least one permit rule matches, **no** deny matches | **PERMIT** (permit or permit_with_obligations) |
| No rule matches | **DENY** (implicit) |
| Mixed `not_applicable` only | **DENY** |

> Evaluator class: `PolicyEvaluator._combine_decisions` implements the deny-override logic.

---

## 11. Constraint & obligation catalogue  (built-ins)
| ID / type | Kind | Key parameters |
|-----------|------|----------------|
| `numeric_limit` | constraint | `value: int` (maximum) |
| `geo_restriction` | constraint | `value: [ISO-country-codes]` |
| `velocity_limit` | constraint | `parameters.count`, `parameters.window_minutes` |
| `time_restriction` | constraint | `parameters.start`, `parameters.end`, `parameters.timezone` |
| `scope_downgrade` / `scope_restriction` | constraint | `parameters.downgraded` / `allowed_scopes` |
| `device_binding` | constraint | `value: device_hash` |
| `ip_restriction` | constraint | `value: [CIDR]` |
| `trust_threshold` | constraint | `value: int` (0-100) |
| *(add your custom)* | obligation/constraint | any – evaluator treats unknown `type` as custom |

**Criticality enum** (obligations): `critical | high | medium | low`.

---

## 12. Context contract (caller → PDP)
```jsonc
{
  "subject": { "id": "…", "type": "user", "properties": {"roles": ["admin"]} },
  "resource": { 
    "id": "…", 
    "type": "document", 
    "properties": {
      "classification": "secret",
      "pdp_application": "my-app"    // Application-scoped policy targeting
    }
  },
  "action":   { "name": "read", "properties": {} },
  "context": {
    "attributes": { "delegator_id": "pers_123" },
    "request_ip": "203.0.113.42",
    "timestamp": "2025-05-02T12:34:56Z"
  }
}
```
All additional data should be nested under `context.attributes`.

### Application-Scoped Policy Loading
When `resource.properties.pdp_application` is provided:
- **Performance**: Loads only relevant application policies vs. all global policies  
- **Isolation**: Applications get their specific policy set
- **Hierarchy**: 5-level inheritance (Global → Domain → Application)
- **Fallback**: Missing field falls back to global policy loading

### Directory Structure
```
policies/
├── global/                    # Level 5: Fallback policies
├── domains/my-domain/
│   ├── shared/               # Level 4: Domain shared
│   ├── cross-environment/    # Level 3: Cross-environment  
│   └── environments/prod/    # Level 2: Domain + environment
└── applications/my-app/      # Level 1: Application specific (highest priority)
```

---

## 13. Path-attribute schema & example
Path attributes allow reuse of regex/glob patterns.
```yaml
path_attributes:
  - name: doc_path            # required, unique per policy
    type: path                # reserved keyword
    patterns:                 # list of glob/regex strings
      - "/docs/*.pdf"
      - "/reports/**/*.xlsx"
    description: "Public & internal docs"
```
A rule can then reference the attribute via `MATCHES`:
```yaml
- resource: document
  action: view
  effect: permit
  when: "resource.properties.full_path MATCHES doc_path"
```

---

## 14. Machine-readable schema
• JSON-Schema: `schema/policy.schema.json`  
• Condition sub-schema: `schema/condition.schema.json`

*(Schemas generated by `tools/generate_schema.py` – regenerate on parser changes).* 