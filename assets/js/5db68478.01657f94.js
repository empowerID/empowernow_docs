"use strict";(self.webpackChunkempowernow_docs=self.webpackChunkempowernow_docs||[]).push([[6421],{28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>o});var t=r(96540);const i={},a=t.createContext(i);function s(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(a.Provider,{value:n},e.children)}},49144:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"services/aria-shield/intro-architecture","title":"ARIA: Agent Risk & Identity Authorization","description":"Introduction","source":"@site/docs/services/aria-shield/intro-architecture.md","sourceDirName":"services/aria-shield","slug":"/services/aria-shield/intro-architecture","permalink":"/empowernow_docs/docs/services/aria-shield/intro-architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/services/aria-shield/intro-architecture.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"ARIA Shield","permalink":"/empowernow_docs/docs/services/aria-shield/"},"next":{"title":"ARIA Patent Portfolio: Comprehensive Attorney Brief","permalink":"/empowernow_docs/docs/services/aria-shield/patent-portfolio"}}');var i=r(74848),a=r(28453);const s={},o="ARIA: Agent Risk & Identity Authorization",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"What is ARIA?",id:"what-is-aria",level:3},{value:"Architecture Position",id:"architecture-position",level:3},{value:"The Problem ARIA Solves",id:"the-problem-aria-solves",level:3},{value:"Core Security Controls",id:"core-security-controls",level:3},{value:"Standards Alignment",id:"standards-alignment",level:3},{value:"How ARIA Fits Your Architecture",id:"how-aria-fits-your-architecture",level:3},{value:"What ARIA Is Not",id:"what-aria-is-not",level:3},{value:"Design Principles",id:"design-principles",level:3},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Part 1: IdP Enhancements for ARIA",id:"part-1-idp-enhancements-for-aria",level:2},{value:"1.1 Token Exchange with ARIA Claims",id:"11-token-exchange-with-aria-claims",level:3},{value:"1.2 Capability Proof API",id:"12-capability-proof-api",level:3},{value:"Part 2: PDP with Strict AuthZEN Compliance",id:"part-2-pdp-with-strict-authzen-compliance",level:2},{value:"2.1 AuthZEN-Compliant Endpoints",id:"21-authzen-compliant-endpoints",level:3},{value:"Part 3: ARIA Gateway Implementation",id:"part-3-aria-gateway-implementation",level:2},{value:"3.1 Main Gateway Service",id:"31-main-gateway-service",level:3},{value:"3.2 AuthZEN Client",id:"32-authzen-client",level:3},{value:"Part 4: BFF Thin Proxy",id:"part-4-bff-thin-proxy",level:2},{value:"Part 5: Deployment Configuration",id:"part-5-deployment-configuration",level:2},{value:"Part 6: ARIA Profile for AuthZEN",id:"part-6-aria-profile-for-authzen",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"aria-agent-risk--identity-authorization",children:"ARIA: Agent Risk & Identity Authorization"})}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.h3,{id:"what-is-aria",children:"What is ARIA?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"ARIA"})," (Agent Risk & Identity Authorization) is a purpose-built security and orchestration gateway for enterprise AI agents. It acts as an ",(0,i.jsx)(n.strong,{children:"MCP-aware policy enforcement point (PEP)"})," between agents and tools/APIs, providing cryptographic verification, fine-grained authorization, and tamper-evident auditing for agent operations."]}),"\n",(0,i.jsx)(n.p,{children:"Unlike traditional API gateways retrofitted for AI, ARIA is designed for machine-speed execution, emergent tool chaining, multi-user delegation, and the need for verifiable evidence of every decision."}),"\n",(0,i.jsx)(n.h3,{id:"architecture-position",children:"Architecture Position"}),"\n",(0,i.jsx)(n.p,{children:"ARIA complements\u2014rather than replaces\u2014your existing stack:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Human/legacy REST traffic"})," \u2192 continues through the existing BFF/API gateway"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Agent\u2192tool traffic"})," \u2192 terminates at ",(0,i.jsx)(n.strong,{children:"ARIA"})," for verification and enforcement"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Identity Provider (IdP)"})," \u2192 issues delegation tokens (RFC 8693 / RFC 9396), optional DPoP"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Policy Decision Point (PDP)"})," \u2192 evaluates policies; ",(0,i.jsx)(n.strong,{children:"ARIA"})," enforces decisions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Membership/Graph Service"})," \u2192 models users, agents, tools, and delegations"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Users \u2500\u25b6 BFF \u2500\u25b6 Backend Services\r\n             \u2514\u2500\u25b6 (only human traffic)\r\nAgents \u2500\u25b6 ARIA Gateway \u2500\u25b6 Tools / MCP Endpoints\r\n             \u2514\u2500\u25b6 PDP / IdP / Membership (control plane)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"the-problem-aria-solves",children:"The Problem ARIA Solves"}),"\n",(0,i.jsx)(n.p,{children:"AI agents stress traditional security in five ways:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Speed & scale"}),": agents act far faster than human review loops."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Emergent behavior"}),": novel tool sequences defeat static allow/deny lists."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multi-user context"}),": one service, many users\u2014strict per-user isolation is mandatory."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multi-step execution"}),": request-by-request checks can\u2019t enforce end-to-end limits."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Auditability"}),": distributed logs aren\u2019t tamper-evident or easy to prove in audits."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"ARIA addresses this with cryptographic enforcement instead of only policy configuration."}),"\n",(0,i.jsx)(n.h3,{id:"core-security-controls",children:"Core Security Controls"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"User-bound agent identities"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Pairwise agent principals (e.g., ",(0,i.jsx)(n.code,{children:"agent:travel-bot:for:alice"}),") cryptographically bound to a single user and verified on every call, providing strict per-user isolation."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Tool schema attestation"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Vendor-signed schema version + content hash verified per call; drift and stale schemas can be detected and enforced."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Privacy-preserving capability proofs (Merkle-based)"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Tokens carry a capability root; the agent proves a single required capability via inclusion proof without revealing the full set (compact tokens, least-revelation)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Plan contracts"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Signed, step-bounded execution plans with parameter fingerprints and per-step/total budgets; deviations are blocked and budgets enforced atomically."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Context-root binding"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A Merkle root over trusted inputs (prompts, constraints, prior outputs) binds execution context; optionally combined with proof-of-possession to prevent context tampering."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Behavioral DNA (BDNA) monitoring"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Baselines over sequences/timing/error patterns; drift triggers obligations (e.g., step-up) or denials for suspected compromise."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Receipt chains"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Signed, hash-chained receipts for each authorized action (including schema and context roots); optionally anchored for long-term, tamper-evident provenance."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"standards-alignment",children:"Standards Alignment"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"OpenID AuthZEN (draft-04)"})," for PDP interactions. ARIA submits subject/action/resource plus ",(0,i.jsx)(n.code,{children:"context"}),"; PDP returns a boolean decision with optional obligations/constraints. ARIA-specific signals (attestation data, capability proofs, plan, context_root, BDNA) are conveyed in ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"resource.properties"})})," and ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"context"})}),"\u2014",(0,i.jsx)(n.strong,{children:"no changes to the spec required"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"OAuth 2.0"}),": ",(0,i.jsx)(n.strong,{children:"Token Exchange (RFC 8693)"})," for delegation with actor chains, ",(0,i.jsx)(n.strong,{children:"Rich Authorization Requests (RFC 9396)"})," for structured authorization details, and optional ",(0,i.jsx)(n.strong,{children:"DPoP (RFC 9449)"})," for proof-of-possession."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"OpenID Connect"}),": standard identity flows; ARIA uses private JWT claims and ",(0,i.jsx)(n.code,{children:"authorization_details"})," where appropriate, remaining backward-compatible."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"how-aria-fits-your-architecture",children:"How ARIA Fits Your Architecture"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Data plane"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Agent calls a tool with a delegation token."}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ARIA Gateway"})," verifies user-binding, attestation, capability proof, plan step, context_root, and BDNA."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PDP (AuthZEN)"})," evaluates authorization; ARIA applies constraints/obligations."]}),"\n",(0,i.jsx)(n.li,{children:"Request is forwarded to the tool/MCP endpoint; response is validated."}),"\n",(0,i.jsxs)(n.li,{children:["A signed ",(0,i.jsx)(n.strong,{children:"receipt"})," is emitted to the audit chain."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Control plane"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"IdP"})," issues delegation tokens; ",(0,i.jsx)(n.strong,{children:"Membership/Graph"})," stores relationships; ",(0,i.jsx)(n.strong,{children:"PDP"})," evaluates; ",(0,i.jsx)(n.strong,{children:"Registry/Audit"})," manage attestations and receipts."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"what-aria-is-not",children:"What ARIA Is Not"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Not an LLM or runtime (ARIA secures agents; it doesn\u2019t run them)."}),"\n",(0,i.jsx)(n.li,{children:"Not an IdP or PDP replacement (it relies on both; it enforces)."}),"\n",(0,i.jsx)(n.li,{children:"Not a general API gateway (it targets agent traffic and MCP/tool calls)."}),"\n",(0,i.jsx)(n.li,{children:"Not a workflow engine (it validates plans; it doesn\u2019t orchestrate them)."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"design-principles",children:"Design Principles"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Cryptographic over configuration"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Zero-trust, per-call verification"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Standards-first, on-wire compatibility"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Fail-closed by default"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Operationally efficient"})," (parallelizable checks; cache where safe)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Audit-complete"})," (every decision yields a tamper-evident receipt)"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,i.jsx)(n.mermaid,{value:'graph TB\r\n    subgraph "Client Layer"\r\n        Agent[AI Agents<br/>LangChain/AutoGen]\r\n        Human[Human Users]\r\n    end\r\n    \r\n    subgraph "ARIA Security Layer"\r\n        ARIA[ARIA Gateway<br/>Agent PEP]\r\n        Registry[Tool Registry<br/>Attestations]\r\n        ReceiptVault[Receipt Vault<br/>KMS-backed]\r\n        BDNAStore[BDNA Store<br/>Behavioral Analysis]\r\n    end\r\n    \r\n    subgraph "Enhanced Services"\r\n        IdP[IdP<br/>+ ARIA Claims]\r\n        PDP[AuthZEN PDP<br/>Strict Compliance]\r\n        Neo4j[Membership<br/>Delegation Graph]\r\n        BFF[BFF<br/>Thin Proxy]\r\n    end\r\n    \r\n    Agent --\x3e|MCP Protocol| ARIA\r\n    Human --\x3e|REST/SSE| BFF\r\n    BFF --\x3e|Proxy /mcp/*| ARIA\r\n    \r\n    ARIA --\x3e|AuthZEN| PDP\r\n    ARIA --\x3e|Query| Neo4j\r\n    ARIA --\x3e|Verify| Registry\r\n    \r\n    style ARIA fill:#FFD700\r\n    style PDP fill:#90EE90'}),"\n",(0,i.jsx)(n.h2,{id:"part-1-idp-enhancements-for-aria",children:"Part 1: IdP Enhancements for ARIA"}),"\n",(0,i.jsx)(n.h3,{id:"11-token-exchange-with-aria-claims",children:"1.1 Token Exchange with ARIA Claims"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# idp/services/aria_token_exchange.py\r\nimport hashlib\r\nimport json\r\nimport uuid\r\nimport jwt\r\nimport os\r\nimport time\r\nfrom typing import List, Dict, Optional\r\nfrom datetime import datetime, timedelta\r\n\r\nclass ARIATokenExchange:\r\n    """\r\n    Enhanced OAuth 2.0 Token Exchange (RFC 8693) with ARIA claims\r\n    Adds capability roots, attestations, plan contracts, and BDNA baselines\r\n    """\r\n    \r\n    def __init__(self, neo4j_client, pdp_client, redis_client):\r\n        self.neo4j = neo4j_client\r\n        self.pdp = pdp_client\r\n        self.redis = redis_client\r\n        self.private_key = load_private_key()\r\n        self.pairwise_salt = os.environ["ARIA_PAIRWISE_SALT"]\r\n        self.issuer = os.environ["ARIA_ISSUER"]\r\n        \r\n    async def exchange_token(\r\n        self,\r\n        subject_token: str,  # User token\r\n        actor_token: str,    # Service token\r\n        requested_tools: List[str],\r\n        plan: Optional[Dict] = None\r\n    ) -> Dict:\r\n        """\r\n        Exchange user + service tokens for ARIA-enhanced delegation token\r\n        """\r\n        # 1. Verify both tokens (NO unsigned decode!)\r\n        user_claims = jwt.decode(\r\n            subject_token,\r\n            self.get_jwks("user"),\r\n            algorithms=["RS256"],\r\n            audience=self.issuer\r\n        )\r\n        \r\n        svc_claims = jwt.decode(\r\n            actor_token,\r\n            self.get_jwks("service"),\r\n            algorithms=["RS256"],\r\n            audience=self.issuer\r\n        )\r\n        \r\n        user_id = user_claims["sub"]\r\n        service_id = svc_claims["sub"]\r\n        \r\n        # 2. Generate pairwise user-bound agent ID\r\n        pairwise_sub = self.generate_pairwise_sub(user_id, service_id)\r\n        agent_id = f"agent:{service_id}:for:{pairwise_sub.split(\':\')[1]}"\r\n        \r\n        # 3. Get delegation from Neo4j\r\n        delegation = await self.neo4j.get_delegation(user_id, agent_id)\r\n        if not delegation:\r\n            return {\r\n                "error": "consent_required",\r\n                "error_description": "No active delegation found",\r\n                "consent_uri": f"/consent?service={service_id}&user={user_id}"\r\n            }\r\n        \r\n        # 4. Build capability Merkle root with domain separation\r\n        capabilities = sorted(delegation["capabilities"])\r\n        tenant = delegation.get("tenant", "default")\r\n        cap_root, cap_tree = await self.build_capability_tree(capabilities, tenant)\r\n        \r\n        # Cache tree for proof generation\r\n        await self.redis.setex(\r\n            f"cap_tree:{agent_id}",\r\n            3600,\r\n            json.dumps({\r\n                "caps": capabilities,\r\n                "tree": cap_tree,\r\n                "tenant": tenant\r\n            })\r\n        )\r\n        \r\n        # 5. Get tool attestations from registry\r\n        attestations = {}\r\n        for tool in requested_tools:\r\n            meta = await self.get_tool_attestation(tool)\r\n            attestations[tool] = {\r\n                "schema_version": meta["schema_version"],\r\n                "schema_hash": meta["schema_hash"],\r\n                "vendor_kid": meta["vendor_kid"],\r\n                "issued_at": meta["issued_at"],\r\n                "expires_at": meta["expires_at"]\r\n            }\r\n        \r\n        # 6. Create plan contract if provided\r\n        plan_contract_jws = None\r\n        if plan:\r\n            plan_contract_jws = await self.create_plan_contract(\r\n                plan, delegation, agent_id\r\n            )\r\n        \r\n        # 7. Get BDNA baseline\r\n        bdna_baseline = delegation.get("bdna_baseline", {})\r\n        \r\n        # 8. Pre-authorize with PDP (AuthZEN compliant)\r\n        pdp_allowed = await self.authorize_delegation(\r\n            agent_id, user_id, requested_tools\r\n        )\r\n        if not pdp_allowed:\r\n            raise Exception("PDP denied delegation")\r\n        \r\n        # 9. Build ARIA passport token\r\n        now = int(time.time())\r\n        passport = {\r\n            # Standard OAuth/OIDC claims\r\n            "iss": self.issuer,\r\n            "sub": pairwise_sub,\r\n            "aud": "aria.gateway",  # Fixed audience for ARIA\r\n            "iat": now,\r\n            "exp": now + 3600,\r\n            "jti": str(uuid.uuid4()),\r\n            \r\n            # RFC 8693 Actor claim\r\n            "act": {\r\n                "sub": agent_id,\r\n                "svc": service_id\r\n            },\r\n            \r\n            # RFC 9396 Rich Authorization\r\n            "authorization_details": [{\r\n                "type": "agent_delegation",\r\n                "tools": requested_tools,\r\n                "locations": [self.get_tool_endpoint(t) for t in requested_tools]\r\n            }],\r\n            \r\n            # ARIA extensions (renamed from \'asog\')\r\n            "aria": {\r\n                # Identity binding\r\n                "bound_sub": pairwise_sub,\r\n                "tenant": tenant,\r\n                \r\n                # Capability proof support\r\n                "cap_root": cap_root,\r\n                "cap_count": len(capabilities),\r\n                \r\n                # Tool attestations\r\n                "attestations": attestations,\r\n                \r\n                # Execution control\r\n                "call_id": str(uuid.uuid4()),\r\n                "max_steps": delegation.get("max_steps", 20),\r\n                \r\n                # Plan contract\r\n                "plan_contract_jws": plan_contract_jws,\r\n                \r\n                # BDNA baseline\r\n                "bdna_baseline": bdna_baseline,\r\n                \r\n                # Budget\r\n                "budget": {\r\n                    "initial": delegation.get("budget", 10.0),\r\n                    "currency": "USD"\r\n                }\r\n            }\r\n        }\r\n        \r\n        # 10. Sign with deterministic headers\r\n        token = jwt.encode(\r\n            passport,\r\n            self.private_key,\r\n            algorithm="RS256",\r\n            headers={"alg": "RS256", "kid": "idp-aria-001", "typ": "JWT"}\r\n        )\r\n        \r\n        return {\r\n            "access_token": token,\r\n            "token_type": "Bearer",\r\n            "expires_in": 3600,\r\n            "agent_id": agent_id\r\n        }\r\n    \r\n    def generate_pairwise_sub(self, user_id: str, service_id: str) -> str:\r\n        """Generate privacy-preserving pairwise identifier"""\r\n        raw = f"pairwise:v1:{user_id}:{service_id}:{self.pairwise_salt}"\r\n        return "pairwise:" + hashlib.sha256(raw.encode()).hexdigest()[:16]\r\n    \r\n    async def build_capability_tree(self, capabilities: List[str], tenant: str) -> tuple:\r\n        """Build Merkle tree with domain separation"""\r\n        if not capabilities:\r\n            return "0" * 64, []\r\n        \r\n        # Domain-separated leaf hashes\r\n        leaves = []\r\n        for cap in capabilities:\r\n            leaf_data = f"cap\\x01{tenant}:{cap}".encode()\r\n            leaves.append(hashlib.sha256(leaf_data).hexdigest())\r\n        \r\n        # Build tree\r\n        tree = [leaves]\r\n        level = leaves[:]\r\n        \r\n        while len(level) > 1:\r\n            next_level = []\r\n            for i in range(0, len(level), 2):\r\n                a = level[i]\r\n                b = level[i + 1] if i + 1 < len(level) else a\r\n                combined = hashlib.sha256(f"{min(a,b)}{max(a,b)}".encode()).hexdigest()\r\n                next_level.append(combined)\r\n            tree.append(next_level)\r\n            level = next_level\r\n        \r\n        return level[0], tree\r\n    \r\n    async def create_plan_contract(self, plan: Dict, delegation: Dict, agent_id: str) -> str:\r\n        """Create cryptographically signed plan contract"""\r\n        total_cost = sum(s.get("cost", 0) for s in plan["steps"])\r\n        if total_cost > delegation.get("max_transaction_value", 0):\r\n            raise ValueError(f"Plan cost {total_cost} exceeds limit")\r\n        \r\n        # Canonicalize params for each step\r\n        for i, step in enumerate(plan["steps"]):\r\n            step["index"] = i\r\n            step["params_fingerprint"] = hashlib.sha256(\r\n                json.dumps(step.get("params", {}), sort_keys=True).encode()\r\n            ).hexdigest()\r\n        \r\n        contract = {\r\n            "plan_id": hashlib.sha256(\r\n                json.dumps(plan, sort_keys=True).encode()\r\n            ).hexdigest()[:16],\r\n            "agent_id": agent_id,\r\n            "total_budget": total_cost,\r\n            "steps": [\r\n                {\r\n                    "index": s["index"],\r\n                    "tool": s["tool"],\r\n                    "params_fingerprint": s["params_fingerprint"],\r\n                    "max_cost": s.get("cost", 0)\r\n                }\r\n                for s in plan["steps"]\r\n            ],\r\n            "created_at": datetime.utcnow().isoformat(),\r\n            "expires_at": (datetime.utcnow() + timedelta(hours=1)).isoformat()\r\n        }\r\n        \r\n        # Sign contract\r\n        return jwt.encode(\r\n            contract,\r\n            self.private_key,\r\n            algorithm="RS256",\r\n            headers={"alg": "RS256", "kid": "idp-aria-001", "typ": "JWT"}\r\n        )\r\n    \r\n    async def authorize_delegation(self, agent_id: str, user_id: str, tools: List[str]) -> bool:\r\n        """Pre-authorize with PDP using AuthZEN"""\r\n        # AuthZEN-compliant request\r\n        response = await self.pdp.evaluate({\r\n            "subject": {\r\n                "type": "agent",\r\n                "id": agent_id,\r\n                "properties": {\r\n                    "bound_user": user_id.split(":")[-1],\r\n                    "service_id": agent_id.split(":")[1]\r\n                }\r\n            },\r\n            "action": {"name": "delegate"},\r\n            "resource": {\r\n                "type": "user",\r\n                "id": user_id\r\n            },\r\n            "context": {\r\n                "tools": tools\r\n            }\r\n        })\r\n        return response.get("decision", False)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"12-capability-proof-api",children:"1.2 Capability Proof API"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# idp/api/aria_capabilities.py\r\nfrom fastapi import APIRouter, Header, HTTPException\r\nimport json\r\nimport jwt\r\n\r\nrouter = APIRouter(prefix="/aria/capabilities")\r\n\r\n@router.post("/proof")\r\nasync def generate_capability_proof(\r\n    capability: str,\r\n    authorization: str = Header(...)\r\n):\r\n    """Generate Merkle proof for ZK capability verification"""\r\n    token = authorization.replace("Bearer ", "")\r\n    claims = jwt.get_unverified_claims(token)\r\n    \r\n    agent_id = claims["act"]["sub"]\r\n    cap_root = claims["aria"]["cap_root"]\r\n    \r\n    # Get cached tree\r\n    tree_data = await redis.get(f"cap_tree:{agent_id}")\r\n    if not tree_data:\r\n        raise HTTPException(404, "Capability tree not found")\r\n    \r\n    data = json.loads(tree_data)\r\n    caps = data["caps"]\r\n    tree = data["tree"]\r\n    \r\n    if capability not in caps:\r\n        raise HTTPException(403, "Capability not granted")\r\n    \r\n    # Generate proof path\r\n    idx = caps.index(capability)\r\n    path = []\r\n    \r\n    for level in tree[:-1]:\r\n        sibling = idx ^ 1\r\n        if sibling < len(level):\r\n            path.append(level[sibling])\r\n        idx //= 2\r\n    \r\n    return {\r\n        "capability": capability,\r\n        "path": path,\r\n        "root": cap_root\r\n    }\n'})}),"\n",(0,i.jsx)(n.h2,{id:"part-2-pdp-with-strict-authzen-compliance",children:"Part 2: PDP with Strict AuthZEN Compliance"}),"\n",(0,i.jsx)(n.h3,{id:"21-authzen-compliant-endpoints",children:"2.1 AuthZEN-Compliant Endpoints"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# pdp/api/authzen.py\r\nfrom fastapi import APIRouter, HTTPException\r\nfrom typing import Dict, List\r\nimport uuid\r\n\r\nrouter = APIRouter(prefix="/access/v1")\r\n\r\nclass AuthZENEvaluator:\r\n    """Strict OpenID AuthZEN draft-04 compliance"""\r\n    \r\n    def __init__(self, neo4j_client):\r\n        self.neo4j = neo4j_client\r\n    \r\n    async def evaluate_internal(self, request: Dict) -> bool:\r\n        """\r\n        Internal evaluation logic - returns boolean only\r\n        All ARIA-specific logic happens here but returns simple bool\r\n        """\r\n        subject = request["subject"]\r\n        action = request["action"]\r\n        resource = request["resource"]\r\n        context = request.get("context", {})\r\n        \r\n        # User-bound agent checks\r\n        if subject.get("type") == "agent":\r\n            agent_id = subject["id"]\r\n            \r\n            # Verify binding if present\r\n            if "bound_user" in subject.get("properties", {}):\r\n                bound_user = subject["properties"]["bound_user"]\r\n                resource_owner = resource.get("properties", {}).get("owner_id")\r\n                \r\n                if resource_owner and bound_user != resource_owner:\r\n                    return False  # Binding violation\r\n            \r\n            # Check delegation\r\n            delegation = await self.neo4j.get_delegation_by_agent(agent_id)\r\n            if not delegation or delegation.get("status") != "active":\r\n                return False\r\n            \r\n            # Check capability\r\n            capability = context.get("capability", action.get("name"))\r\n            if capability not in delegation.get("capabilities", []):\r\n                return False\r\n            \r\n            # Trust threshold\r\n            if "trust_score" in context:\r\n                required = delegation.get("trust_threshold", 70)\r\n                if context["trust_score"] < required:\r\n                    return False  # Could be conditional, but AuthZEN wants bool\r\n            \r\n            # BDNA drift\r\n            if context.get("bdna_score", 0) > 0.8:\r\n                return False\r\n            \r\n            # Transaction limits\r\n            if "transaction_value" in context:\r\n                max_value = delegation.get("max_transaction_value", 0)\r\n                if context["transaction_value"] > max_value:\r\n                    return False\r\n        \r\n        # Default allow if all checks pass\r\n        return True\r\n\r\nevaluator = AuthZENEvaluator(neo4j_client)\r\n\r\n@router.post("/evaluation")\r\nasync def evaluation(request: Dict) -> Dict:\r\n    """\r\n    AuthZEN single evaluation endpoint\r\n    Strict compliance: returns only {"decision": bool}\r\n    """\r\n    # Validate required fields\r\n    for field in ["subject", "action", "resource"]:\r\n        if field not in request:\r\n            raise HTTPException(400, f"Missing required field: {field}")\r\n    \r\n    # Evaluate\r\n    decision = await evaluator.evaluate_internal(request)\r\n    \r\n    # Return ONLY the decision (strict AuthZEN)\r\n    return {"decision": decision}\r\n\r\n@router.post("/evaluations")\r\nasync def evaluations(request: Dict) -> Dict:\r\n    """\r\n    AuthZEN batch evaluation endpoint (\'boxcar\')\r\n    Returns only {"evaluations": [{"decision": bool}, ...]}\r\n    """\r\n    # Extract common fields\r\n    base = {\r\n        "subject": request.get("subject"),\r\n        "action": request.get("action"),\r\n        "context": request.get("context", {})\r\n    }\r\n    \r\n    # Evaluate each resource\r\n    results = []\r\n    for evaluation in request.get("evaluations", []):\r\n        eval_request = {\r\n            **base,\r\n            "resource": evaluation["resource"]\r\n        }\r\n        decision = await evaluator.evaluate_internal(eval_request)\r\n        results.append({"decision": decision})\r\n    \r\n    # Return ONLY decisions (strict AuthZEN)\r\n    return {"evaluations": results}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"part-3-aria-gateway-implementation",children:"Part 3: ARIA Gateway Implementation"}),"\n",(0,i.jsx)(n.h3,{id:"31-main-gateway-service",children:"3.1 Main Gateway Service"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# aria/gateway.py\r\nfrom fastapi import FastAPI, Request, Header, HTTPException\r\nfrom typing import Optional, Dict\r\nimport httpx\r\nimport jwt\r\nimport hashlib\r\nimport json\r\nimport time\r\nimport uuid\r\n\r\napp = FastAPI(title="ARIA Gateway", version="1.0.0")\r\n\r\nclass ARIAGateway:\r\n    """\r\n    Agent Risk & Identity Authorization Gateway\r\n    Implements all patent-pending security controls\r\n    """\r\n    \r\n    def __init__(self):\r\n        # Service clients\r\n        self.pdp = AuthZENClient(os.environ["PDP_URL"])\r\n        self.neo4j = Neo4jClient(os.environ["NEO4J_URI"])\r\n        self.redis = RedisClient(os.environ["REDIS_URL"])\r\n        self.kafka = KafkaProducer(os.environ["KAFKA_BROKERS"])\r\n        self.registry = ToolRegistry(os.environ["REGISTRY_URL"])\r\n        \r\n        # Configuration\r\n        self.config = ARIAConfig()\r\n        self.jwks = load_jwks()\r\n        \r\n    async def process_mcp_request(\r\n        self,\r\n        tool: str,\r\n        request: Request,\r\n        authorization: str = Header(...),\r\n        x_aria_cap_proof: Optional[str] = Header(None),\r\n        x_aria_plan: Optional[str] = Header(None),\r\n        dpop: Optional[str] = Header(None)\r\n    ) -> Dict:\r\n        """Main ARIA security pipeline"""\r\n        start_time = time.time()\r\n        \r\n        try:\r\n            # 1. Verify JWT passport\r\n            token = authorization.replace("Bearer ", "")\r\n            passport = jwt.decode(\r\n                token,\r\n                self.jwks,\r\n                algorithms=["RS256"],\r\n                audience="aria.gateway"\r\n            )\r\n            \r\n            aria = passport["aria"]\r\n            agent_id = passport["act"]["sub"]\r\n            call_id = aria["call_id"]\r\n            tenant = aria["tenant"]\r\n            \r\n            body = await request.json()\r\n            \r\n            # 2. Verify user binding (Patent #1)\r\n            if not self.verify_user_binding(passport):\r\n                raise HTTPException(403, "User binding violation")\r\n            \r\n            # 3. Verify tool attestation (Patent #2)\r\n            if self.config.enforce_attestation:\r\n                if not await self.verify_attestation(tool, aria["attestations"].get(tool)):\r\n                    raise HTTPException(403, "Attestation mismatch")\r\n            \r\n            # 4. Verify capability proof (Patent #3)\r\n            if self.config.enforce_cap_proof and x_aria_cap_proof:\r\n                proof = json.loads(x_aria_cap_proof)\r\n                if not await self.verify_capability_proof(\r\n                    proof["capability"],\r\n                    proof,\r\n                    aria["cap_root"],\r\n                    tenant\r\n                ):\r\n                    raise HTTPException(403, "Invalid capability proof")\r\n            \r\n            # 5. Enforce plan contract (Patent #4)\r\n            if aria.get("plan_contract_jws"):\r\n                if not await self.verify_plan_step(\r\n                    aria["plan_contract_jws"],\r\n                    call_id,\r\n                    tool,\r\n                    body\r\n                ):\r\n                    raise HTTPException(403, "Plan violation")\r\n            \r\n            # 6. Generate context root (Patent #5)\r\n            context_root = await self.generate_context_root(call_id, passport)\r\n            \r\n            # Verify DPoP if provided\r\n            if dpop and aria.get("dpop_jkt"):\r\n                if not self.verify_dpop_context(dpop, context_root):\r\n                    raise HTTPException(403, "DPoP context mismatch")\r\n            \r\n            # 7. Check BDNA drift (Patent #7)\r\n            bdna_score = await self.check_bdna_drift(agent_id, tool, body)\r\n            \r\n            if self.config.bdna_mode == "enforce" and bdna_score > self.config.bdna_threshold:\r\n                raise HTTPException(403, f"BDNA drift {bdna_score:.2f}")\r\n            \r\n            # 8. Budget check (idempotent)\r\n            tool_meta = await self.registry.get_tool(tool)\r\n            cost = tool_meta["cost_per_call"]\r\n            \r\n            budget_ok, debited, remaining = await self.debit_budget(\r\n                call_id, agent_id, cost\r\n            )\r\n            if not budget_ok:\r\n                raise HTTPException(402, "Budget exceeded")\r\n            \r\n            # 9. PDP authorization (strict AuthZEN)\r\n            pdp_decision = await self.pdp.evaluate(\r\n                subject={\r\n                    "type": "agent",\r\n                    "id": agent_id,\r\n                    "properties": {\r\n                        "bound_user": passport["sub"].split(":")[-1],\r\n                        "service_id": agent_id.split(":")[1]\r\n                    }\r\n                },\r\n                action={"name": "execute"},\r\n                resource={\r\n                    "type": "tool",\r\n                    "id": tool,\r\n                    "properties": {\r\n                        "schema_hash": aria["attestations"][tool]["schema_hash"],\r\n                        "plan_step": await self.get_plan_step(call_id) if aria.get("plan_contract_jws") else None\r\n                    }\r\n                },\r\n                context={\r\n                    "bdna_score": bdna_score,\r\n                    "budget_remaining": remaining,\r\n                    "context_root": context_root,\r\n                    "capability": tool.split(":")[-1],  # Extract capability\r\n                    "transaction_value": body.get("amount")\r\n                }\r\n            )\r\n            \r\n            if not pdp_decision:\r\n                raise HTTPException(403, "PDP denied")\r\n            \r\n            # 10. Egress validation\r\n            if not await self.validate_egress(tool, tool_meta):\r\n                raise HTTPException(403, "Egress denied")\r\n            \r\n            # 11. Forward to tool\r\n            response = await self.forward_to_tool(\r\n                tool_meta["endpoint"],\r\n                body,\r\n                {\r\n                    "X-Delegator-ID": passport["sub"],\r\n                    "X-Agent-ID": agent_id,\r\n                    "X-ARIA-Context-Root": context_root\r\n                }\r\n            )\r\n            \r\n            # 12. Emit receipt (Patent #6)\r\n            receipt = await self.emit_receipt(\r\n                passport=passport,\r\n                tool=tool,\r\n                params_hash=hashlib.sha256(\r\n                    json.dumps(body, sort_keys=True).encode()\r\n                ).hexdigest(),\r\n                schema_hash=aria["attestations"][tool]["schema_hash"],\r\n                context_root=context_root,\r\n                bdna_score=bdna_score,\r\n                decision="Allow"\r\n            )\r\n            \r\n            # 13. Update context and step\r\n            await self.save_tool_output(call_id, tool, response)\r\n            if aria.get("plan_contract_jws"):\r\n                await self.increment_step(call_id)\r\n            \r\n            # Record metrics\r\n            self.metrics.record(\r\n                tool=tool,\r\n                agent=agent_id,\r\n                status="Allow",\r\n                latency=time.time() - start_time\r\n            )\r\n            \r\n            return response\r\n            \r\n        except HTTPException as e:\r\n            # Emit deny receipt\r\n            if \'agent_id\' in locals():\r\n                await self.emit_receipt(\r\n                    passport=passport if \'passport\' in locals() else None,\r\n                    tool=tool,\r\n                    params_hash=hashlib.sha256(\r\n                        json.dumps(body, sort_keys=True).encode()\r\n                    ).hexdigest() if \'body\' in locals() else None,\r\n                    decision="Deny",\r\n                    reason=str(e.detail)\r\n                )\r\n            \r\n            self.metrics.record(\r\n                tool=tool,\r\n                agent=locals().get("agent_id"),\r\n                status="Deny",\r\n                latency=time.time() - start_time,\r\n                reason=str(e.detail)\r\n            )\r\n            raise\r\n    \r\n    def verify_user_binding(self, passport: Dict) -> bool:\r\n        """Verify user-bound agent identity"""\r\n        bound_sub = passport["aria"]["bound_sub"]\r\n        user_sub = passport["sub"]\r\n        agent_id = passport["act"]["sub"]\r\n        \r\n        # Agent ID must match binding\r\n        if ":for:" not in agent_id:\r\n            return False\r\n        \r\n        agent_bound = agent_id.split(":for:")[1]\r\n        pairwise = bound_sub.split(":")[-1]\r\n        \r\n        return (\r\n            bound_sub == user_sub and\r\n            agent_bound == pairwise\r\n        )\r\n    \r\n    async def verify_attestation(self, tool: str, attestation: Dict) -> bool:\r\n        """Verify tool schema attestation"""\r\n        if not attestation:\r\n            return False\r\n        \r\n        meta = await self.registry.get_tool(tool)\r\n        \r\n        # Check current version\r\n        if (attestation["schema_version"] == meta["schema_version"] and\r\n            attestation["schema_hash"] == meta["schema_hash"]):\r\n            return True\r\n        \r\n        # Check rollout window for previous version\r\n        if meta.get("previous_version"):\r\n            if (attestation["schema_version"] == meta["previous_version"] and\r\n                attestation["schema_hash"] == meta.get("previous_hash")):\r\n                # Within rollout window?\r\n                if time.time() - meta.get("updated_at", 0) < 14400:  # 4 hours\r\n                    return True\r\n        \r\n        return False\r\n    \r\n    async def verify_capability_proof(\r\n        self,\r\n        capability: str,\r\n        proof: Dict,\r\n        cap_root: str,\r\n        tenant: str\r\n    ) -> bool:\r\n        """Verify ZK capability proof"""\r\n        # Reconstruct leaf hash with domain separation\r\n        h = hashlib.sha256(f"cap\\x01{tenant}:{capability}".encode()).hexdigest()\r\n        \r\n        # Walk up tree\r\n        for sibling in proof.get("path", []):\r\n            lo, hi = sorted([h, sibling])\r\n            h = hashlib.sha256(f"{lo}{hi}".encode()).hexdigest()\r\n        \r\n        return h == cap_root\r\n    \r\n    async def verify_plan_step(\r\n        self,\r\n        plan_jws: str,\r\n        call_id: str,\r\n        tool: str,\r\n        params: Dict\r\n    ) -> bool:\r\n        """Verify plan contract compliance"""\r\n        # Decode plan\r\n        plan = jwt.get_unverified_claims(plan_jws)\r\n        \r\n        # Get server-tracked step (never trust client!)\r\n        step_key = f"call:{call_id}:step"\r\n        step_idx = int(await self.redis.get(step_key) or 0)\r\n        \r\n        if step_idx >= len(plan["steps"]):\r\n            return False  # Plan complete\r\n        \r\n        step = plan["steps"][step_idx]\r\n        \r\n        # Verify tool\r\n        if step["tool"] != tool:\r\n            return False\r\n        \r\n        # Verify params fingerprint\r\n        params_fingerprint = hashlib.sha256(\r\n            json.dumps(params, sort_keys=True).encode()\r\n        ).hexdigest()\r\n        \r\n        return params_fingerprint == step["params_fingerprint"]\r\n    \r\n    async def generate_context_root(self, call_id: str, passport: Dict) -> str:\r\n        """Generate Merkle root of trusted context"""\r\n        elements = []\r\n        \r\n        # Previous tool outputs\r\n        outputs = await self.redis.lrange(f"context:{call_id}:outputs", 0, -1)\r\n        for output in outputs:\r\n            elements.append(hashlib.sha256(output.encode()).hexdigest())\r\n        \r\n        # Add call ID\r\n        elements.append(hashlib.sha256(call_id.encode()).hexdigest())\r\n        \r\n        # Build Merkle root\r\n        if not elements:\r\n            return "0" * 64\r\n        \r\n        level = elements[:]\r\n        while len(level) > 1:\r\n            next_level = []\r\n            for i in range(0, len(level), 2):\r\n                a = level[i]\r\n                b = level[i + 1] if i + 1 < len(level) else a\r\n                combined = hashlib.sha256(f"{min(a,b)}{max(a,b)}".encode()).hexdigest()\r\n                next_level.append(combined)\r\n            level = next_level\r\n        \r\n        return level[0]\r\n    \r\n    async def check_bdna_drift(self, agent_id: str, tool: str, params: Dict) -> float:\r\n        """Check behavioral drift"""\r\n        # Record call\r\n        await self.redis.lpush(\r\n            f"bdna:{agent_id}:calls",\r\n            json.dumps({\r\n                "tool": tool,\r\n                "ts": time.time(),\r\n                "params_size": len(json.dumps(params))\r\n            })\r\n        )\r\n        await self.redis.ltrim(f"bdna:{agent_id}:calls", 0, 99)  # Keep last 100\r\n        \r\n        # Get recent calls\r\n        calls = await self.redis.lrange(f"bdna:{agent_id}:calls", 0, -1)\r\n        if len(calls) < 20:\r\n            return 0.0  # Not enough data\r\n        \r\n        # Simple drift calculation (extend with ML in production)\r\n        recent = [json.loads(c) for c in calls[:20]]\r\n        baseline = [json.loads(c) for c in calls[80:100]] if len(calls) >= 100 else recent\r\n        \r\n        # Tool sequence difference\r\n        recent_tools = [c["tool"] for c in recent]\r\n        baseline_tools = [c["tool"] for c in baseline]\r\n        \r\n        # Jaccard distance\r\n        recent_set = set(recent_tools)\r\n        baseline_set = set(baseline_tools)\r\n        \r\n        if not recent_set and not baseline_set:\r\n            return 0.0\r\n        \r\n        intersection = len(recent_set & baseline_set)\r\n        union = len(recent_set | baseline_set)\r\n        \r\n        return 1.0 - (intersection / union if union else 0)\r\n    \r\n    async def debit_budget(self, call_id: str, agent_id: str, cost: float) -> tuple:\r\n        """Idempotent budget debit"""\r\n        # Check if already processed\r\n        seen_key = f"budget:seen:{call_id}"\r\n        if await self.redis.get(seen_key):\r\n            remaining = float(await self.redis.get(f"budget:{agent_id}") or 0)\r\n            return True, 0.0, remaining\r\n        \r\n        # Atomic debit\r\n        budget_key = f"budget:{agent_id}"\r\n        current = float(await self.redis.get(budget_key) or 10.0)\r\n        \r\n        if cost > current:\r\n            return False, 0.0, current\r\n        \r\n        # Debit and mark seen\r\n        new_balance = current - cost\r\n        await self.redis.set(budget_key, new_balance, ex=86400)\r\n        await self.redis.setex(seen_key, 600, "1")\r\n        \r\n        return True, cost, new_balance\r\n    \r\n    async def emit_receipt(self, **kwargs) -> Dict:\r\n        """Emit tamper-evident receipt"""\r\n        agent_id = kwargs.get("passport", {}).get("act", {}).get("sub", "unknown")\r\n        \r\n        # Get previous hash\r\n        prev_hash = await self.redis.get(f"receipt:last:{agent_id}")\r\n        if not prev_hash:\r\n            prev_hash = "0" * 64\r\n        \r\n        # Build receipt\r\n        receipt = {\r\n            "id": str(uuid.uuid4()),\r\n            "timestamp": datetime.utcnow().isoformat(),\r\n            "agent_id": agent_id,\r\n            "tool": kwargs.get("tool"),\r\n            "params_hash": kwargs.get("params_hash"),\r\n            "schema_hash": kwargs.get("schema_hash"),\r\n            "context_root": kwargs.get("context_root"),\r\n            "bdna_score": kwargs.get("bdna_score", 0),\r\n            "decision": kwargs.get("decision"),\r\n            "reason": kwargs.get("reason"),\r\n            "prev_hash": prev_hash\r\n        }\r\n        \r\n        # Sign receipt\r\n        receipt_jws = jwt.encode(\r\n            receipt,\r\n            self.private_key,\r\n            algorithm="RS256",\r\n            headers={"alg": "RS256", "kid": "aria-gw-001", "typ": "JWT"}\r\n        )\r\n        \r\n        # Compute hash\r\n        receipt_hash = hashlib.sha256(receipt_jws.encode()).hexdigest()\r\n        \r\n        # Store as last\r\n        await self.redis.set(f"receipt:last:{agent_id}", receipt_hash, ex=86400)\r\n        \r\n        # Emit to Kafka\r\n        await self.kafka.send(\r\n            "aria.receipts",\r\n            key=agent_id.encode(),\r\n            value=receipt_jws.encode()\r\n        )\r\n        \r\n        # Daily anchor (first receipt of day)\r\n        if await self.is_first_today(agent_id):\r\n            await self.anchor_to_kms(receipt_hash)\r\n        \r\n        return receipt\r\n\r\ngateway = ARIAGateway()\r\n\r\n@app.post("/mcp/{tool}")\r\nasync def handle_mcp_request(\r\n    tool: str,\r\n    request: Request,\r\n    authorization: str = Header(...),\r\n    x_aria_cap_proof: Optional[str] = Header(None),\r\n    x_aria_plan: Optional[str] = Header(None),\r\n    dpop: Optional[str] = Header(None)\r\n):\r\n    """Main MCP endpoint"""\r\n    return await gateway.process_mcp_request(\r\n        tool=tool,\r\n        request=request,\r\n        authorization=authorization,\r\n        x_aria_cap_proof=x_aria_cap_proof,\r\n        x_aria_plan=x_aria_plan,\r\n        dpop=dpop\r\n    )\n'})}),"\n",(0,i.jsx)(n.h3,{id:"32-authzen-client",children:"3.2 AuthZEN Client"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# aria/clients/authzen_client.py\r\nimport httpx\r\n\r\nclass AuthZENClient:\r\n    """Strict AuthZEN-compliant PDP client"""\r\n    \r\n    def __init__(self, base_url: str, timeout: float = 1.5):\r\n        self.base = base_url.rstrip("/")\r\n        self.http = httpx.AsyncClient(timeout=timeout)\r\n    \r\n    async def evaluate(\r\n        self,\r\n        subject: Dict,\r\n        action: Dict,\r\n        resource: Dict,\r\n        context: Optional[Dict] = None\r\n    ) -> bool:\r\n        """\r\n        Single evaluation - returns boolean only\r\n        Strict AuthZEN compliance\r\n        """\r\n        payload = {\r\n            "subject": subject,\r\n            "action": action,\r\n            "resource": resource\r\n        }\r\n        if context:\r\n            payload["context"] = context\r\n        \r\n        response = await self.http.post(\r\n            f"{self.base}/access/v1/evaluation",\r\n            json=payload\r\n        )\r\n        response.raise_for_status()\r\n        \r\n        # AuthZEN only returns decision boolean\r\n        return response.json().get("decision", False)\r\n    \r\n    async def evaluations(\r\n        self,\r\n        subject: Dict,\r\n        action: Dict,\r\n        resources: List[Dict],\r\n        context: Optional[Dict] = None\r\n    ) -> List[bool]:\r\n        """\r\n        Batch evaluation - returns list of booleans\r\n        Strict AuthZEN compliance\r\n        """\r\n        payload = {\r\n            "subject": subject,\r\n            "action": action,\r\n            "evaluations": [{"resource": r} for r in resources]\r\n        }\r\n        if context:\r\n            payload["context"] = context\r\n        \r\n        response = await self.http.post(\r\n            f"{self.base}/access/v1/evaluations",\r\n            json=payload\r\n        )\r\n        response.raise_for_status()\r\n        \r\n        # Extract decisions from AuthZEN response\r\n        evaluations = response.json().get("evaluations", [])\r\n        return [e.get("decision", False) for e in evaluations]\n'})}),"\n",(0,i.jsx)(n.h2,{id:"part-4-bff-thin-proxy",children:"Part 4: BFF Thin Proxy"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# bff/middleware/aria_proxy.py\r\nfrom fastapi import Request, Response\r\nimport httpx\r\nimport jwt\r\nimport os\r\n\r\nclass ARIAProxy:\r\n    """Thin proxy to route agent traffic to ARIA Gateway"""\r\n    \r\n    def __init__(self):\r\n        self.aria_url = os.environ.get("ARIA_GATEWAY_URL", "http://aria:8080")\r\n        self.client = httpx.AsyncClient(timeout=30.0)\r\n    \r\n    async def is_agent_request(self, request: Request) -> bool:\r\n        """Determine if request should go to ARIA"""\r\n        # MCP paths always go to ARIA\r\n        if request.url.path.startswith("/mcp/"):\r\n            return True\r\n        \r\n        # Check for agent tokens\r\n        if auth := request.headers.get("Authorization"):\r\n            try:\r\n                # Quick check without validation\r\n                token = auth.replace("Bearer ", "")\r\n                claims = jwt.decode(\r\n                    token,\r\n                    options={"verify_signature": False}\r\n                )\r\n                # ARIA audience means agent token\r\n                if claims.get("aud") == "aria.gateway":\r\n                    return True\r\n                # Actor claim means delegation\r\n                if "act" in claims:\r\n                    return True\r\n            except:\r\n                pass\r\n        \r\n        return False\r\n    \r\n    async def proxy_to_aria(self, request: Request) -> Response:\r\n        """Proxy request to ARIA Gateway"""\r\n        # Build target URL\r\n        target_url = f"{self.aria_url}{request.url.path}"\r\n        if request.url.query:\r\n            target_url += f"?{request.url.query}"\r\n        \r\n        # Forward headers\r\n        headers = dict(request.headers)\r\n        headers["X-Forwarded-For"] = request.client.host\r\n        headers["X-Forwarded-Proto"] = request.url.scheme\r\n        \r\n        # Forward body\r\n        body = await request.body()\r\n        \r\n        # Proxy request\r\n        response = await self.client.request(\r\n            method=request.method,\r\n            url=target_url,\r\n            headers=headers,\r\n            content=body\r\n        )\r\n        \r\n        # Return response\r\n        return Response(\r\n            content=response.content,\r\n            status_code=response.status_code,\r\n            headers=dict(response.headers)\r\n        )\r\n\r\n# bff/main.py\r\nfrom fastapi import FastAPI, Request\r\n\r\napp = FastAPI()\r\naria_proxy = ARIAProxy()\r\n\r\n@app.middleware("http")\r\nasync def route_to_aria(request: Request, call_next):\r\n    """Route agent traffic to ARIA, keep human traffic in BFF"""\r\n    if await aria_proxy.is_agent_request(request):\r\n        return await aria_proxy.proxy_to_aria(request)\r\n    return await call_next(request)\r\n\r\n# Your existing human endpoints remain unchanged\n'})}),"\n",(0,i.jsx)(n.h2,{id:"part-5-deployment-configuration",children:"Part 5: Deployment Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# docker-compose.yml\r\nversion: \'3.9\'\r\n\r\nservices:\r\n  # Enhanced existing services\r\n  idp:\r\n    build: ./idp\r\n    environment:\r\n      - ARIA_ENABLED=true\r\n      - ARIA_PAIRWISE_SALT=${PAIRWISE_SALT}\r\n      - ARIA_ISSUER=https://idp.example.com\r\n      - NEO4J_URI=bolt://neo4j:7687\r\n      - REDIS_URL=redis://redis:6379\r\n  \r\n  pdp:\r\n    build: ./pdp\r\n    environment:\r\n      - AUTHZEN_STRICT_MODE=true  # Only return decision boolean\r\n      - NEO4J_URI=bolt://neo4j:7687\r\n  \r\n  membership:\r\n    build: ./membership\r\n    environment:\r\n      - ARIA_DELEGATIONS_ENABLED=true\r\n      - NEO4J_URI=bolt://neo4j:7687\r\n  \r\n  bff:\r\n    build: ./bff\r\n    environment:\r\n      - ARIA_PROXY_ENABLED=true\r\n      - ARIA_GATEWAY_URL=http://aria:8080\r\n  \r\n  # New ARIA Gateway\r\n  aria:\r\n    build: ./aria\r\n    ports:\r\n      - "8080:8080"\r\n    environment:\r\n      - SERVICE_NAME=aria-gateway\r\n      - PDP_URL=http://pdp:8000\r\n      - NEO4J_URI=bolt://neo4j:7687\r\n      - REDIS_URL=redis://redis:6379\r\n      - KAFKA_BROKERS=kafka:9092\r\n      - REGISTRY_URL=http://tool-registry:8081\r\n      - ENFORCE_ATTESTATION=true\r\n      - ENFORCE_CAP_PROOF=true\r\n      - ENFORCE_PLAN=true\r\n      - BDNA_MODE=shadow\r\n      - BDNA_THRESHOLD=0.35\r\n  \r\n  tool-registry:\r\n    build: ./tool-registry\r\n    ports:\r\n      - "8081:8081"\r\n    environment:\r\n      - REDIS_URL=redis://redis:6379\n'})}),"\n",(0,i.jsx)(n.h2,{id:"part-6-aria-profile-for-authzen",children:"Part 6: ARIA Profile for AuthZEN"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-markdown",children:'# ARIA Profile for OpenID AuthZEN\r\n\r\nThis profile defines how ARIA uses OpenID AuthZEN for AI agent authorization.\r\n\r\n## Standard Compliance\r\n\r\nARIA is fully compliant with OpenID AuthZEN draft-04, using only the standard\r\nrequest/response format with the following conventions:\r\n\r\n## Request Conventions\r\n\r\n### Subject Types\r\n- `"agent"` - AI agent identity\r\n- `"user_bound_agent"` - Agent bound to specific user\r\n\r\n### Subject Properties\r\n- `bound_user` - User ID the agent is bound to\r\n- `service_id` - Parent service identity\r\n\r\n### Resource Properties\r\n- `schema_hash` - Tool schema attestation hash\r\n- `attestation_issuer` - Tool attestation issuer\r\n- `plan_step` - Current step in plan execution\r\n\r\n### Context Fields\r\n- `capability` - Capability being exercised\r\n- `bdna_score` - Behavioral drift score [0..1]\r\n- `context_root` - Merkle root of trusted context\r\n- `budget_remaining` - Remaining budget\r\n- `transaction_value` - Value of transaction\r\n\r\n## Response Format\r\n\r\nARIA PDPs return ONLY the standard AuthZEN response:\r\n- Single: `{"decision": true|false}`\r\n- Batch: `{"evaluations": [{"decision": true|false}, ...]}`\r\n\r\nAll enforcement logic (obligations, constraints) is handled by ARIA Gateway.\n'})}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"This final design provides:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Complete rebranding"})," from ASOG to ARIA (Agent Risk & Identity Authorization)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Strict AuthZEN compliance"})," - PDP endpoints return only decision booleans"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"All patent-pending features"})," preserved in resource.properties and context"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Clean separation"})," - Human traffic in BFF, agent traffic in ARIA"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Production ready"})," - All security controls, monitoring, and deployment configs"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The architecture maintains all seven patentable innovations while ensuring full OpenID AuthZEN interoperability, creating a standards-compliant yet innovative security platform for AI agents."})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);