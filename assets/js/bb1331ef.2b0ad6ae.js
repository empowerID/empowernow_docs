"use strict";(self.webpackChunkempowernow_docs=self.webpackChunkempowernow_docs||[]).push([[8506],{28453:(e,n,o)=>{o.d(n,{R:()=>t,x:()=>c});var s=o(96540);const i={},r=s.createContext(i);function t(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(r.Provider,{value:n},e.children)}},99923:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>t,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"services/crud-service/explanation/execution-loop","title":"execution-loop","description":"Execution loop and readiness","source":"@site/docs/services/crud-service/explanation/execution-loop.md","sourceDirName":"services/crud-service/explanation","slug":"/services/crud-service/explanation/execution-loop","permalink":"/empowernow_docs/docs/services/crud-service/explanation/execution-loop","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/services/crud-service/explanation/execution-loop.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"engine-overview","permalink":"/empowernow_docs/docs/services/crud-service/explanation/engine-overview"},"next":{"title":"LDAP connector idempotency","permalink":"/empowernow_docs/docs/services/crud-service/explanation/ldap-connector-idempotency"}}');var i=o(74848),r=o(28453);const t={},c=void 0,d={},a=[{value:"Execution loop and readiness",id:"execution-loop-and-readiness",level:3},{value:"State flow",id:"state-flow",level:4},{value:"Ready node rules",id:"ready-node-rules",level:4}];function l(e){const n={h3:"h3",h4:"h4",li:"li",mermaid:"mermaid",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h3,{id:"execution-loop-and-readiness",children:"Execution loop and readiness"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Initialization"}),": mark zero-dependency nodes as PENDING."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Readiness"}),": a node is ready when it is PENDING and all its dependencies are COMPLETED."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Concurrency"}),": all ready nodes may run in parallel; the loop continues until completion or a user-interaction node is WAITING."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Completion"}),": upon node completion, outbound edges are evaluated to activate successors."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"state-flow",children:"State flow"}),"\n",(0,i.jsx)(n.mermaid,{value:"stateDiagram-v2\r\n    [*] --\x3e PendingRoots: load workflow\r\n    PendingRoots --\x3e Scheduling: mark zero-dependency nodes PENDING\r\n    Scheduling --\x3e Running: launch ready nodes\r\n    Running --\x3e Waiting: user-interaction node sets WAITING\r\n    Waiting --\x3e Resumed: resume called with input\r\n    Resumed --\x3e Scheduling: evaluate edges, find next ready\r\n    Running --\x3e Completed: all nodes terminal"}),"\n",(0,i.jsx)(n.h4,{id:"ready-node-rules",children:"Ready node rules"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Not in terminal or WAITING state."}),"\n",(0,i.jsx)(n.li,{children:"Status is PENDING (or treated as such)."}),"\n",(0,i.jsx)(n.li,{children:"All dependencies COMPLETED."}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);